#!/usr/bin/perl
#
# This is a utility program intended to convert tab separated dump
# of contents of A.E. Kohts archives (which has been tracked
# in several external systems) into TSV text file ready to be imported
# into DSpace.
#
# Subset of Dublin Core metadata fields are populated together
# with SDM specific metadata fields. Schema for these SDM specific
# metadata fields should be loaded into DSpace prior to the import
# of TSV generated by this utility.
#
# There are two main modes of operation of the utility: initial import
# and mass update of metadata in external system with consequent
# update of information in DSpace. First mode implies that DSpace
# database is empty (at least it should not contain any information
# about the items which are being loaded from external system),
# while in the second mode this utility should produce TSV
# which will update already existing items.
#
#
# Several notes on the identification of the items: each item in DSpace
# is listed in the table "item" and is uniquely identified by item.item_id,
# which is further associated with unique handle (as specified by handle.net):
#
#   dspace=> select * from handle where resource_type_id = 2;
#    handle_id |     handle     | resource_type_id | resource_id
#   -----------+----------------+------------------+-------------
#            4 | 123456789/4    |                2 |           2
#            3 | 123456789/3    |                2 |
#            5 | 123456789/5    |                2 |           3
#            6 | 123456789/6    |                2 |           4
#           11 | 123456789/10.1 |                2 |           8
#           12 | 123456789/10.2 |                2 |           9
#           10 | 123456789/10   |                2 |           9
#           14 | 123456789/14   |                2 |          12
#   (8 rows)
#
# Deleted items do not free handles (check handle_id 3 in the example above),
# resource type id(s) are stored in core/Constants.java (as of DSpace 4.1).
#
#
# A.E. Kohts SDM archives items are also uniquely identified.
# Historically archives were catalogued in two takes.
#
# First take happened for several tens of years after death of A.E. Kohts
# by several different people and was finally summed up around 1998-1999
# by Novikova N.A.:
# https://www.dropbox.com/sh/plawjce2lbtzzku/AACkqdQfG9azt46-L6UP5sRba
# (2208 storage items, documents from which are addressed additionally
# with OF (main funds) identifiers 9595-9609, 9626/1-11, 9649-9651,
# 9662/1-2, 9664/1-2, 9749/1-2, 9764-9768, 9771-9776, 10109/1-16,
# 10141/1-623, 10621/1-19, 12430/1-275, 12497/1-1212)
#
# Second take was made in 2012-2013 by Kalacheva I.P.
# (1713 storage items all addressed as OF-15845/1-1713)
#
# Upon import of the catalogs into DSpace we decided to store
# original (physical) identification of the documents, so it's
# easily possible to refer to the old identification having found
# the item in DSpace archive.
#
#
# So the structure of input data is as follows:
#
#   storage group -- physical identification system top level identifier;
#                    the group inside which all the items have unique
#                    storage (inventory) numbers. A.E. Kohts archives
#                    stored in the SDM are organized in two
#                    storage groups (as described above).
#
#   storage item  -- physical identification system second level identifier;
#                    Storage item is uniquely identified in the scope
#                    of some storage group by its inventory number.
#                    A.E. Kohts archives storage item is usually
#                    a group of objects usually combined into a paper
#                    folder or envelope or other type of wrapping.
#
#   item          -- is a document (usually a folder with several pages
#                    inside of it) or other object or several objects
#                    (such as pins for example), which is stored in a
#                    storage item possibly together with several other
#                    items (usually somehow logically interconnected).
#                    Every item in A.E. Kohts archive is uniquely identified
#                    by the its fund number and the number inside the fund
#                    (e.g. OF-10141/1)
#
#   fund number -- is the element of logical identification system which
#                  groups items according to some property of the items.
#                  "funds" termonilogy comes from Russian museology where
#                  all the museum items are grouped into funds according
#                  to the purpose of the fund. There are two main types
#                  of funds which are used for A.E. Kohts archives:
#                  main funds ("ОФ" -- acronym of "основной фонд" in Russian)
#                  and auxiliary funds ("НВФ" -- acronym of
#                  "научно-вспомогательный фонд" in Russian).
#

use strict;
use warnings;

use utf8;

use Data::Dumper;
$Data::Dumper::Sortkeys = 1;

# Data::Dumper to output UTF-8
# http://www.perlmonks.org/?node_id=759457
$Data::Dumper::Useqq = 1;
{
    no warnings 'redefine';
    sub Data::Dumper::qquote {
        my $s = shift;
        return "'$s'";
    }
}

use IPC::Cmd;
use Getopt::Long;
use Carp;
use File::Path;
use Text::CSV;

# unbuffered output
$| = 1;

binmode(STDOUT, ':encoding(UTF-8)');

my $o_names = [
    'input-file=s',
    'dump-tsv-raw',
    'dump-tsv-struct',
    'dump-data-desc',
    'descriptor-dump=s',
    'data-split-by-tab',
    'data-split-by-comma',
    'output-tsv',
    'debug',
    'initial-import', 'target-collection-handle=s',
    'dump-storage-item=s',
    'tsv-output',
    'input-line=s',
    ];
my $o = {};
Getopt::Long::GetOptionsFromArray(\@ARGV, $o, @{$o_names});

my $data_desc_struct = {
    'external_archive_storage_base' => 'c:/_gdm/raw-afk',    

    'input_tsv_fields' => [qw/
        date_of_status
        status
        number_of_pages
        id
        of_number
        nvf_number
        number_suffix
        storage_number
        scanned_doc_id
        classification_code
        doc_name
        doc_property_full
        doc_property_genuine
        doc_type
        doc_date
        doc_desc
        archive_date
        /],

    'authors_canonical' => {
        "Barlow N." => [ {"name" => "Barlow, Emma Nora", "lang" => "en"}, ],
        "Edwards W.N." => [ {"name" => "Edwards, Wilfred Norman", "lang" => "en"}, ],
        "Артоболевский В.М." => [ "Артоболевский, Владимир Михайлович", ],
        "Белоголовый Ю.А." => [ "Белоголовый, Юрий Аполлонович" ],
        "Белышев В.А." => [],
        "Берг А.Н." => [ "" ],
        "Биашвили В.Я." => [],
        "Бобринский Н.А." => [ "Бобринский, Николай Алексеевич" ],
        "Бунчур А.," => [],
        "Бутурлин С.А." => [],
        "Васильев Е.Н." => [],
        "Ватагин В.А." => [ "Ватагин, Василий Алексеевич", {"name" => "Vatagin, Vasily", "lang" => "en"}, ],
        "Виноградов Н.В." => [],
        "Волкац Д.С." => [],
        "Вяжлинский Д.М." => [ "Вяжлинский, Дмитрий Михайлович" ],
        "Гептнер В.Г." => [ "Гептнер, Владимир Георгиевич" ],
        "Гладков Н.А." => [],
        "Голиков А." => [],
        "Дембовский Я.К." => [],
        "Дементьев Г.П." => [ "Дементьев, Георгий Петрович" ],
        "Дробыш А." => [],
        "Дурова-Садовская А.В." => [ "Дурова-Садовская, Анна Владимировна" ],
        "Евстафьев В.М." => [ "Евстафьев, Виктор Михайлович" ],
        "Жандармов А.П." => [ "Анжанов (Жандармов), Анатолий Петрович" ],
        "Железнякова О.У." => [],
        "Житков Б.М." => [ "Житков, Борис Михайлович" ],
        "Завадовский Б.М." => [ "Завадовский, Борис Михайлович" ],
        "Захаров В." => [],
        "Игнатьева В.Н." => [ "Игнатьева, Вера Николаевна" ],
        "Кожевников Г.А." => [ "Кожевников, Григорий Александрович" ],
        "Конёнкова М.И." => [ "Конёнкова, Маргарита Ивановна" ],
        "Конюс А.Г." => [ "Конюс, Андрей Георгиевич" ],
        "Котс А." => [ "Котс, Александр Федорович", {"name" => "Kohts (Coates), Alexander Erich", "lang" => "en"}, ],
        "Котс А.Р." => ["Котс, Александр Рудольфович"],
        "Котс А.Ф." => [ "Котс, Александр Федорович", {"name" => "Kohts (Coates), Alexander Erich", "lang" => "en"}, ],
        "Котс Р.А." => [ "Котс, Рудольф Александрович", {"name" => "Kohts, Rudolf Alfred", "lang" => "en"}, ],
        "Котс С.Р." => [ "Котс, Сергей Рудольфович" ],
        "Кириллова Н.В." => [],
        "Крупская Н.К." => [ "Крупская, Надежда Константиновна", ],
        "Крушинский Л.В." => [ "Крушинский, Леонид Викторович" ],
        "Ладыгина-Котс Н.Н." => [ "Ладыгина-Котс, Надежда Николаевна", {"name" => "Ladygina-Kohts, Nadezhda Nikolaevna", "lang" => "en"}, ],
        "Левыкина Н.Ф." => [ "Левыкина, Наталья Федоровна" ],
        "Логинова Н.Я." => [],
        "Лоренц Ф.К." => [ "Лоренц, Фёдор Карлович" ],
        "Малахова М.Ф." => [],
        "Мардис П.Е." => [],
        "Мензбир М.А." => [ "Мензбир, Михаил Александрович", {"name" => "Menzbier, Mikhail Aleksandrovich", "lang" => "en"}, ],
        "Минцлова А.Р." => [ "Минцлова, Анна Рудольфовна" ],
        "Муцетони В.М." => [ "Муцетони, Валентина Михайловна" ],
        "Неизвестный автор" => [ "Неизвестный автор", {"name" => "Unknown author", "lang" => "en"}, ],
        "Песков В.М." => [],
        "Петров Ф.Н." => [],
        "Плавильщиков Н.Н." => [ "Плавильщиков, Николай Николаевич" ],
        "Полосатова Е.В." => [],
        "Полякова Ю.Ф." => [],
        "Потапов М.М." => [],
        "Псахис Б.С." => [],
        "Пупершлаг Е.А." => [ "Пупершлаг, Евгения Александровна" ],
        "Рейнвальд Л.Л." => [],
        "Садовникова-Кольцова М.П." => [],
        "Сироткин М.A." => [],
        "Слудский А.А." => [],
        "Смолин П.П." => [ "Смолин, Петр Петрович" ],
        "Сосновский И.П." => [ "Сосновский, Игорь Петрович" ],
        "Спангенберг Е.П." => [ "Спангенберг, Евгений Павлович" ],
        "Суворов И.П." => [],
        "Судиловская А.М." => [ "Судиловская, Ангелина Михайловна" ],
        "Сукачев В.Н." => [],
        "Толстой С.С." => [ "Толстой, Сергей Сергеевич" ],
        "Туров С.С." => [ "Туров, Сергей Сергеевич" ],
        "Фабри К.Э." => [ "Фабри, Курт Эрнестович" ],
        "Федулов Ф.Е." => [ "Федулов, Филипп Евтихиевич" ],
        "Федулов Д.Я." => [ "Федулов, Дмитрий Яковлевич" ],
        "Формозов А.Н." => [ "Формозов, Александр Николаевич" ],
        "Хануков А." => [],
        "Хахлов В.А." => [],
        "Цингер В.Я." => [ "Цингер, Василий Яковлевич" ],
        "Чибисов Н.Е." => [ "Чибисов, Никандр Евлампиевич" ],
        "Чибисова Н.Н." => [],
        "Шиллингер Ф.Ф." => [ "Шиллингер, Франц Францович" ],
        "Шперлинг М." => [],
        "Штернберг П.К." => [ "Штернберг, Павел Карлович" ],
        },
    
    'storage_groups' => {
        1 => {
            'name' => 'Novikova',
            'name_readable' => 'опись Новиковой Н.А.',
            'name_readable_en' => 'Novikova N.A.',
            'funds' => [qw/
                           1237
                           1363 1364 1365 1366 1367 1368
                           2116
                           6912
                           9595 9596 9597 9598 9599 9600 9601 9602 9603 9604 9605 9606 9607 9608 9609
                           9626 9649 9650 9651 9662 9664
                           9749 9764 9765 9766 9767 9771 9774 9775 9776 9768 9772 9773 
                           10109
                           10141
                           10621
                           12430 12497
                           /],
        },
        2 => {
            'name' => 'Kalacheva',
            'name_readable' => 'опись Калачевой И.П.',
            'name_readable_en' => 'Kalacheva I.P.',
            'funds' => ['15845'],
            },
        },
    };

$data_desc_struct->{'storage_groups_by_fund_number'} = {};
$data_desc_struct->{'storage_groups_by_name'} = {};

foreach my $st_gr_id (keys %{$data_desc_struct->{'storage_groups'}}) {
    Carp::confess("storage group name must be unique")
        if $data_desc_struct->{'storage_groups_by_name'}->{$data_desc_struct->{'storage_groups'}->{$st_gr_id}->{'name'}};
    
    $data_desc_struct->{'storage_groups'}->{$st_gr_id}->{'id'} = $st_gr_id;
    $data_desc_struct->{'storage_groups_by_name'}->{$data_desc_struct->{'storage_groups'}->{$st_gr_id}->{'name'}} =
        $data_desc_struct->{'storage_groups'}->{$st_gr_id};
    
    foreach my $fund_id (@{$data_desc_struct->{'storage_groups'}->{$st_gr_id}->{'funds'}}) {
        if ($data_desc_struct->{'storage_groups_by_fund_number'}->{$fund_id}) {
            Carp::confess("Fund [$fund_id] used more than once, please fix");
        }

        $data_desc_struct->{'storage_groups_by_fund_number'}->{$fund_id} = $st_gr_id;
    }
}

sub separated_list_to_struct {
    my ($in_string, $opts) = @_;
    
    $opts = {} unless $opts;
    $opts->{'delimiter'} = "," unless $opts->{'delimiter'};
    
    my $out = {
        'string' => $in_string,
        'array' => [],
        'by_name0' => {},
        'by_position0' => {},
        'by_name1' => {},
        'by_position1' => {},
        'opts' => $opts,
        'number_of_elements' => 0,
        };
    my $i = 0;
    
    foreach my $el (split($opts->{'delimiter'}, $in_string)) {
        push (@{$out->{'array'}}, $el);
        
        $out->{'by_name0'}->{$el} = $i;
        $out->{'by_name1'}->{$el} = $i + 1;
        $out->{'by_position0'}->{$i} = $el;
        $out->{'by_position1'}->{$i + 1} = $el;
        
        $i = $i + 1;
    }
    
    $out->{'number_of_elements'} = $i;
    
    return $out;
}

sub safe_string {
  my ($str, $default) = @_;

  $default = "" unless defined($default);

  if (defined($str)) {
    return $str;
  }
  else {
    return $default;
  }
}

sub trim {
    my ($string, $symbols) = @_;
  
    if (ref($string) eq 'SCALAR') {
        my $tstr = safe_string($$string);
    
        return 0 if $tstr eq ''; # nothing to trim, do not waste cpu cycles
    
        if ($symbols) {
            $tstr =~ s/^[${symbols}]+//so;
            $tstr =~ s/[${symbols}]+$//so;
        }
        else {
            $tstr =~ s/^\s+//so;
            $tstr =~ s/\s+$//so;
        }

        if ($tstr ne $$string) {
            $$string = $tstr;
            return 1;
        }
        else {
            return 0;
        }
    }
    else {
        $string = safe_string($string);

        return "" if $string eq ''; # nothing to trim, do not waste cpu cycles

        if ($symbols) {
            $string =~ s/^[${symbols}]+//so;
            $string =~ s/[${symbols}]+$//so;
        }
        else {
            $string =~ s/^\s+//so;
            $string =~ s/\s+$//so;
        }

        return $string;
    }
}

sub extract_authors {
    my ($text) = @_;

    my $doc_authors = [];
    
    $text =~ s/Автор: Ладыгина. Котс/Автор: Ладыгина-Котс/;
    $text =~ s/Автор: Ладыгина - Котс/Автор: Ладыгина-Котс/;

    while ($text && $text =~ /^\s*Автор:\s([Нн]еизвестный\sавтор|Ладыгина\s*?\-\s*?Котс\s?Н.\s?Н.|[^\s]+?\s+?([^\s]?\.?\s?[^\s]?\.?|))(\s|,)(.+)$/) {
        my $author = $1;
        $text = $4;
        
        Carp::confess("Unknown author: $author")
            unless defined($data_desc_struct->{'authors_canonical'}->{$author});

        if (scalar (@{$data_desc_struct->{'authors_canonical'}->{$author}}) == 0) {
            push @{$doc_authors}, {"name" => $author, "lang" => "ru"};
        } else {
            foreach my $a_struct (@{$data_desc_struct->{'authors_canonical'}->{$author}}) {
                if (ref($a_struct) eq '') {
                    push @{$doc_authors}, {"name" => $a_struct, "lang" => "ru"};
                } else {
                    push @{$doc_authors}, $a_struct;
                }
            }
        }
    }

    $text = trim($text);
    if ($text && $text =~ /^и др\.(.+)/) {
        $text = $1;
    }

    if (!scalar(@{$doc_authors})) {
        push @{$doc_authors}, {"name" => "Котс, Александр Федорович", "lang" => "ru"}, {"name" => "Kohts (Coates), Alexander Erich", "lang" => "en"};
    }

    return {
        'extracted_struct' => $doc_authors,
        'trimmed_input' => $text,
        };
}

sub extract_meta_data {
    my ($text) = @_;

    my $possible_field_labels = {
        'doc_type' => {'label' => 'Техника', 'pos' => undef, 'value' => undef},
        'doc_date' => {'label' => 'Время создания', 'pos' => undef, 'value' => undef},
        'doc_desc' => {'label' => 'Описание', 'pos' => undef, 'value' => undef},
        };
    
    my $sorted_fls = [];

    foreach my $fl (keys %{$possible_field_labels}) {
        my $fl_match_pos = index($text, $possible_field_labels->{$fl}->{'label'} . ":");
        if ($fl_match_pos < 0) {
            delete($possible_field_labels->{$fl});
        } else {
            $possible_field_labels->{$fl}->{'pos'} = $fl_match_pos;
        }
    }
    
    $sorted_fls = [sort {$possible_field_labels->{$a}->{'pos'} <=> $possible_field_labels->{$b}->{'pos'}} keys %{$possible_field_labels}];

    my $i = 0;
    foreach my $fl (@{$sorted_fls}) {
        my $rx_str = '^(.*?)' . $possible_field_labels->{$fl}->{'label'} . '\s*?:\s*?(.+)(\s*?';

        if ($i < (scalar(@{$sorted_fls}) - 1)) {
            $rx_str = $rx_str . $possible_field_labels->{$sorted_fls->[$i+1]}->{'label'} . '\s*?:\s*?.+$)';
        } else {
            $rx_str = $rx_str . '\s*?$)';
        }

#        print $rx_str . "\n";
        if ($text =~ /$rx_str/) {
            $possible_field_labels->{$fl}->{'value'} = trim($2);
#            print $1 . "\n";
#            print $2 . "\n";
#            print $3 . "\n";
            $text = $1 . $3;
        }
        $i++;
    }

#    print Data::Dumper::Dumper($possible_field_labels);

    $possible_field_labels->{'trimmed_input'} = trim($text);
    return $possible_field_labels;
}

sub tsv_read_and_validate {
    my ($input_file, $o) = @_;

    $o = {} unless $o;

    my $doc_struct = {
        'array' => [],
        'by_line_number' => {},
        'by_storage' => {},
        'funds' => {},
        'storage_items_by_fund_number' => {},
        'title_line' => {},
        'total_input_lines' => 0,
        };

    # read xls output and populate $list
    my $list = [];
    my $fh;
    open($fh, "<" . $input_file) || Carp::confess("Can't open [$input_file] for reading");
    binmode($fh, ':encoding(UTF-8)');
    while (my $l = <$fh>) {
        push @{$list}, $l;
    }
    close($fh);

    TSV_LINE: foreach my $line (@{$list}) {
        $doc_struct->{'total_input_lines'}++;

        if ($o->{'input-line'}) {
            next TSV_LINE if $doc_struct->{'total_input_lines'} ne $o->{'input-line'};
        }

        my $line_struct = {
            #'orig_line' => $line,
            'orig_field_values_array' => [split("\t", $line, -1)],
            'by_field_name' => {},
            'orig_line_number' => $doc_struct->{'total_input_lines'},
            };

        my $i = 0;
        foreach my $fvalue (@{$line_struct->{'orig_field_values_array'}}) {
            # generic input text filtering
            my $nvalue = $fvalue;

            # remove surrounding quotes
            if ($nvalue && substr($nvalue, 0, 1) eq '"' &&
                substr($nvalue, length($nvalue) - 1, 1) eq '"') {
                $nvalue = substr($nvalue, 1, length($nvalue) - 2);
            }

            # remove heading and trailing whitespace
            $nvalue = trim($nvalue);

            # replace all repeated space with one space symbol
            while ($nvalue =~ /\s\s/) {
                $nvalue =~ s/\s\s/ /gs;
            }

            # push dangling commas and dots to the text
            $nvalue =~ s/\s\,(\s|$)/\,$1/g;
            $nvalue =~ s/\s\.(\s|$)/\.$1/g;
            $nvalue =~ s/\s\;(\s|$)/\;$1/g;

            $nvalue =~ s/""/"/g;

            $line_struct->{'by_field_name'}->{$data_desc_struct->{'input_tsv_fields'}->[$i]} = $nvalue;
            $i++;
        }

        if ($o->{'dump-tsv-raw'}) {
            print Data::Dumper::Dumper($line_struct);
            next TSV_LINE;
        }

        # skip title
        if ($line_struct->{'by_field_name'}->{'date_of_status'} eq 'date of status') {
            if ($doc_struct->{'total_input_lines'} ne 1) {
                Carp::confess("Unexpected title line on the line number [$doc_struct->{'total_input_lines'}]");
            }

            $doc_struct->{'title_line'} = $line_struct;
            next TSV_LINE;
        }

        push @{$doc_struct->{'array'}}, $line_struct;
        $doc_struct->{'by_line_number'}->{$doc_struct->{'total_input_lines'}} = $line_struct;

        my $st_gr_id;
        my $fund_number;
        if ($line_struct->{'by_field_name'}->{'of_number'}) {
            $fund_number = $line_struct->{'by_field_name'}->{'of_number'};
            
            $doc_struct->{'funds'}->{$fund_number} = {}
                unless $doc_struct->{'funds'}->{$fund_number};
            
            if ($doc_struct->{'funds'}->{$fund_number}->{'type'} &&
                $doc_struct->{'funds'}->{$fund_number}->{'type'} ne "of") {
                Carp::confess("Data integrity error: fund [$fund_number] is referenced as [of] and as [$doc_struct->{'funds'}->{$fund_number}->{'type'}]");
            }

            $doc_struct->{'funds'}->{$fund_number}->{'type'} = "of";

            $st_gr_id = $data_desc_struct->{'storage_groups_by_fund_number'}->{$fund_number};
        } elsif ($line_struct->{'by_field_name'}->{'nvf_number'}) {
            $fund_number = $line_struct->{'by_field_name'}->{'nvf_number'};

            $doc_struct->{'funds'}->{$fund_number} = {}
                unless $doc_struct->{'funds'}->{$fund_number};

            if ($doc_struct->{'funds'}->{$fund_number}->{'type'} &&
                $doc_struct->{'funds'}->{$fund_number}->{'type'} ne "nvf") {
                Carp::confess("Data integrity error: fund [$fund_number] is referenced as [nvf] and as [$doc_struct->{'funds'}->{$fund_number}->{'type'}]");
            }

            $doc_struct->{'funds'}->{$fund_number}->{'type'} = "nvf";

            $st_gr_id = $data_desc_struct->{'storage_groups_by_fund_number'}->{$fund_number};
        } elsif ($line_struct->{'by_field_name'}->{'storage_number'} eq '796') {
            $st_gr_id = $data_desc_struct->{'storage_groups_by_name'}->{'Novikova'}->{'id'};
        } else {
            print Data::Dumper::Dumper($line_struct);
            Carp::confess("of_number and nvf_number are undefined for the line [$doc_struct->{'total_input_lines'}]");
        }

        if (!$st_gr_id) {
            print Data::Dumper::Dumper($line_struct);
            Carp::confess("Unable to find storage group for the line [$doc_struct->{'total_input_lines'}]");
        } else {
            Carp::confess("Invalid storage group id [$st_gr_id]")
                unless defined($data_desc_struct->{'storage_groups'}->{$st_gr_id});

            $doc_struct->{'by_storage'}->{$st_gr_id} = {}
                unless $doc_struct->{'by_storage'}->{$st_gr_id};
        }

        my $st_id;
        if ($data_desc_struct->{'storage_groups'}->{$st_gr_id}->{'name'} eq 'Novikova') {
            $st_id = $line_struct->{'by_field_name'}->{'storage_number'};
        } else {
            $st_id = $line_struct->{'by_field_name'}->{'number_suffix'};
        }
        if (!$st_id) {
            print Data::Dumper::Dumper($line_struct);
            Carp::confess("Unable to detect storage_number for line [$doc_struct->{'total_input_lines'}]");
        }

        my $storage_struct = $doc_struct->{'by_storage'}->{$st_gr_id}->{$st_id} // {'documents' => []};
        push @{$storage_struct->{'documents'}}, $line_struct;
        $doc_struct->{'by_storage'}->{$st_gr_id}->{$st_id} = $storage_struct;
    
        if ($fund_number) {
            $doc_struct->{'storage_items_by_fund_number'}->{$fund_number} = {}
                unless $doc_struct->{'storage_items_by_fund_number'}->{$fund_number};
            $doc_struct->{'storage_items_by_fund_number'}->{$fund_number}->{$st_id} = $storage_struct;
        }
    }

    foreach my $st_gr_id (keys %{$doc_struct->{'by_storage'}}) {
        foreach my $storage_number (sort {$a <=> $b} keys %{$doc_struct->{'by_storage'}->{$st_gr_id}}) {
            my $storage_struct = $doc_struct->{'by_storage'}->{$st_gr_id}->{$storage_number};
            
            my $tsv_struct = {
                'dc.contributor.author[en]' => [],
                'dc.contributor.author[ru]' => [],
                'dc.creator[en]' => [],
                'dc.creator[ru]' => [],
                'dc.date.created' => '',
#                'dc.date.issued' => '',
                'dc.description[ru]' => '',
#                    'ОФ-10141/1 "От автора". Введение к тому музейно-методических работ. Полнота: полная. Подлинность: копия. Способ воспроизведения: машинопись. Примечания: Т. I' .
#                    '||' .
#                    'НВФ-2116/460 "От автора". Введение к тому музейно-методических работ. Полнота: полная. Подлинность: оригинал. Способ воспроизведения: машинопись. Примечания: Т. I ; 1 экз.основной + 2 экз. редакции (5 лл.,6 лл.)',
                'dc.identifier.other[ru]' => '',
#                'dc.identifier.uri' => '', # http://hdl.handle.net/123456789/4
                'dc.language.iso[en]' => 'ru',
                'dc.publisher[en]' => 'State Darwin Museum',
                'dc.publisher[ru]' => 'Государственный Дарвиновский Музей',
                'dc.subject[en]' => '',
                'dc.subject[ru]' => 'Музейное дело',
                'dc.title[ru]' => '',
                'dc.type[en]' => 'Text',
#                'sdm-archive-workflow.date.cataloged' => '28.01.2012',
#                'sdm-archive-workflow.date.digitized' => '28.01.2012',
            };

            if (scalar(@{$storage_struct->{'documents'}}) == 1) {
                
                my $title_struct = extract_authors($storage_struct->{'documents'}->[0]->{'by_field_name'}->{'doc_name'});
                foreach my $author (@{$title_struct->{'extracted_struct'}}) {
                    push @{$tsv_struct->{'dc.contributor.author[' . $author->{'lang'} . ']'}}, $author->{'name'};
                    push @{$tsv_struct->{'dc.creator[' . $author->{'lang'} . ']'}}, $author->{'name'};
                }

                my $meta = extract_meta_data($title_struct->{'trimmed_input'});
                my $doc_type = $meta->{'doc_type'} ? $meta->{'doc_type'}->{'value'} : "";
                my $doc_date = $meta->{'doc_date'} ? $meta->{'doc_date'}->{'value'} : "";
                my $doc_desc = $meta->{'doc_desc'} ? $meta->{'doc_desc'}->{'value'} : "";

                if ($storage_struct->{'documents'}->[0]->{'by_field_name'}->{'doc_type'} && $doc_type) {
                    Carp::confess("Unable to determine document type: " . Data::Dumper::Dumper($storage_struct));
                }
                $tsv_struct->{'sdm-archive-workflow.misc.document-type'} =
                    $storage_struct->{'documents'}->[0]->{'by_field_name'}->{'doc_type'} || $doc_type;

                if ($storage_struct->{'documents'}->[0]->{'by_field_name'}->{'doc_desc'} && $doc_desc) {
                    Carp::confess("Unable to determine document description: " . Data::Dumper::Dumper($storage_struct));
                }
                $tsv_struct->{'sdm-archive-workflow.misc.notes'} =
                    $storage_struct->{'documents'}->[0]->{'by_field_name'}->{'doc_desc'} || $doc_desc;

                if ($storage_struct->{'documents'}->[0]->{'by_field_name'}->{'doc_date'} && $doc_date) {
                    Carp::confess("Unable to determine document date: " . Data::Dumper::Dumper($storage_struct));
                }
                $tsv_struct->{'dc.date.created'} =
                    $storage_struct->{'documents'}->[0]->{'by_field_name'}->{'doc_date'} || $doc_date;

                $tsv_struct->{'dc.title[ru]'} = $meta->{'trimmed_input'};

                $tsv_struct->{'dc.identifier.other[ru]'} = 'Место хранения ' . $storage_number .
                    ' (' . $data_desc_struct->{'storage_groups'}->{$st_gr_id}->{'name_readable'} . ')';
                $tsv_struct->{'dc.identifier.other[en]'} = 'Storage item ' . $storage_number .
                    ' (' . $data_desc_struct->{'storage_groups'}->{$st_gr_id}->{'name_readable_en'} . ')';

                $tsv_struct->{'sdm-archive-workflow.misc.completeness'} = $storage_struct->{'documents'}->[0]->{'by_field_name'}->{'doc_property_full'};
                $tsv_struct->{'sdm-archive-workflow.misc.authenticity'} = $storage_struct->{'documents'}->[0]->{'by_field_name'}->{'doc_property_genuine'};
                $tsv_struct->{'sdm-archive-workflow.misc.classification-code'} = $storage_struct->{'documents'}->[0]->{'by_field_name'}->{'classification_code'};
                $tsv_struct->{'sdm-archive-workflow.misc.archive-date'} = $storage_struct->{'documents'}->[0]->{'by_field_name'}->{'archive_date'};

                $tsv_struct->{'dc.description[ru]'} = "";
                if ($storage_struct->{'documents'}->[0]->{'by_field_name'}->{'of_number'}) {
                    $tsv_struct->{'dc.description[ru]'} .= "ОФ-" .
                        $storage_struct->{'documents'}->[0]->{'by_field_name'}->{'of_number'} .
                        ($storage_struct->{'documents'}->[0]->{'by_field_name'}->{'number_suffix'} ?
                            "/" . $storage_struct->{'documents'}->[0]->{'by_field_name'}->{'number_suffix'}
                            : "")
                        ;
                } else {
                    $tsv_struct->{'dc.description[ru]'} .= "НВФ-" .
                        $storage_struct->{'documents'}->[0]->{'by_field_name'}->{'nvf_number'} .
                        ($storage_struct->{'documents'}->[0]->{'by_field_name'}->{'number_suffix'} ?
                            "/" . $storage_struct->{'documents'}->[0]->{'by_field_name'}->{'number_suffix'}
                            : "")
                    ;
                }
                
                my $desc_elements = [];
                my $push_desc_el = sub {
                    my ($str) = @_;
                    push (@{$desc_elements}, $str . ($str =~ /\.$/ ? "" : "."));
                };
                
                $push_desc_el->($tsv_struct->{'dc.title[ru]'});
                if ($tsv_struct->{'dc.date.created'}) {
                    $push_desc_el->("Время создания: " . $tsv_struct->{'dc.date.created'});
                }
                if ($tsv_struct->{'sdm-archive-workflow.misc.completeness'}) {
                    $push_desc_el->("Полнота: " . $tsv_struct->{'sdm-archive-workflow.misc.completeness'});
                }
                if ($tsv_struct->{'sdm-archive-workflow.misc.authenticity'}) {
                    $push_desc_el->("Подлинность: " . $tsv_struct->{'sdm-archive-workflow.misc.authenticity'});
                }
                if ($tsv_struct->{'sdm-archive-workflow.misc.document-type'}) {
                    $push_desc_el->("Способ воспроизведения: " . $tsv_struct->{'sdm-archive-workflow.misc.document-type'});
                }
                if ($tsv_struct->{'sdm-archive-workflow.misc.notes'}) {
                    $push_desc_el->("Примечания: " . $tsv_struct->{'sdm-archive-workflow.misc.notes'});
                }

                $tsv_struct->{'dc.description[ru]'} .= " " . join (" ", @{$desc_elements});

                $storage_struct->{'tsv_struct'} = $tsv_struct;
            } else {

                # - detect and store storage paths here against $data_desc_struct->{'external_archive_storage_base'}
                # - check "scanned" status (should be identical for all the documents in the storage item)
                foreach my $item (@{$storage_struct->{'documents'}}) {
                    if ($storage_struct->{'status'}) {
                        if ($item->{'by_field_name'}->{'status'} ne $storage_struct->{'status'}) {
                            if (
                                $item->{'by_field_name'}->{'status'} eq 'published' ||
                                (
                                    $item->{'by_field_name'}->{'status'} eq 'docbook' &&
                                    $storage_struct->{'status'} ne 'published'
                                ) ||
                                (
                                    $item->{'by_field_name'}->{'status'} eq 'ocr' &&
                                    $storage_struct->{'status'} ne 'published' &&
                                    $storage_struct->{'status'} ne 'docbook'
                                ) ||
                                (
                                    $item->{'by_field_name'}->{'status'} eq 'scanned' &&
                                    $storage_struct->{'status'} ne 'published' &&
                                    $storage_struct->{'status'} ne 'docbook' &&
                                    $storage_struct->{'status'} ne 'ocr'
                                ) ||
                                (
                                    $item->{'by_field_name'}->{'status'} eq 'scanning' &&
                                    $storage_struct->{'status'} ne 'published' &&
                                    $storage_struct->{'status'} ne 'docbook' &&
                                    $storage_struct->{'status'} ne 'ocr' &&
                                    $storage_struct->{'status'} ne 'scanned'
                                )
                                ) {
                                $storage_struct->{'status'} = $item->{'by_field_name'}->{'status'};
                                $storage_struct->{'date_of_status'} = $item->{'by_field_name'}->{'date_of_status'};
                            }
                        }
                    } else {
                        $storage_struct->{'status'} = $item->{'by_field_name'}->{'status'};
                        $storage_struct->{'date_of_status'} = $item->{'by_field_name'}->{'date_of_status'};
                    }

                    foreach my $array_uf (qw/scanned_doc_id/) {
                        $storage_struct->{$array_uf} = [] unless
                            $storage_struct->{$array_uf};
                        if (! scalar(grep($_ eq $item->{'by_field_name'}->{$array_uf}, @{$storage_struct->{$array_uf}}))) {
                            push @{$storage_struct->{$array_uf}}, $item->{'by_field_name'}->{$array_uf};
                        }
                    }
                }
            }

#            $storage_struct->{'tsv_struct'} = $tsv_struct;
        }
    }

    return $doc_struct;
}

sub tsv_output_record {
    my ($tsv_record, $o) = @_;
    $o = {} unless $o;

    $o->{'mode'} = 'values' unless $o->{'mode'};

    my $out_array = [];

    if ($o->{'mode'} eq 'labels') {
        # id must be the _first_ column in tsv:
        # https://github.com/DSpace/DSpace/blob/master/dspace-api/src/main/java/org/dspace/app/bulkedit/DSpaceCSV.java#L522
        my $labels = ["id", sort(keys %{$tsv_record})];
    
        $out_array = [];
        foreach my $v (@{$labels}) {
            $v =~ s/"/""/g;
            push @{$out_array}, '"' . $v . '"';
        }
    } elsif ($o->{'mode'} eq 'values') {
        $out_array = ["+"];
        foreach my $field_name (sort keys %{$tsv_record}) {
            my $field_value = $tsv_record->{$field_name};
            
            if (ref($field_value) eq 'ARRAY') {
                $field_value = join("||", @{$field_value});
            }

            $field_value =~ s/"/""/g;
            push @{$out_array}, '"' . $field_value . '"';
        }
    }
    
    print join(",", @{$out_array}) . "\n";
}


if ($o->{'dump-data-desc'}) {
    print Data::Dumper::Dumper($data_desc_struct);
    exit 0;
} elsif ($o->{'data-split-by-tab'}) {
    my $line_number = 0;
    while (my $l = <STDIN>) {
        $line_number = $line_number + 1;
        my $fields = [split("\t", $l, -1)];
        my $i = 0;
        foreach my $f (@{$fields}) {
            $i = $i + 1;
            print $line_number . "." . $i . ": " . $f . "\n";
        }
    }    
} elsif ($o->{'data-split-by-comma'}) {
    my $csv = Text::CSV->new();

    my $line_number = 0;
    while (my $l = <STDIN>) {
        $line_number = $line_number + 1;

        $csv->parse($l);

        my $fields = [$csv->fields()];
        
        my $i = 0;
        foreach my $f (@{$fields}) {
            $i = $i + 1;
            print $line_number . "." . $i . ": " . $f . "\n";
        }
        print "\n";
    }    
} elsif ($o->{'descriptor-dump'}) {
    my $d = $o->{'descriptor-dump'} . "\n";
    $d = trim($d);

    if (!$d) {
        while (my $l = <STDIN>) {
            $d .= $l;
        }
    }

    my $ds = separated_list_to_struct($d);

    foreach my $f (@{$ds->{'array'}}) {
        print $ds->{'by_name1'}->{$f} . ": " . $f . "\n";
    }
} elsif ($o->{'dump-storage-item'}) {
    my ($st_gr_id, $st_number) = split(" ", safe_string($o->{'dump-storage-item'}));
    Carp::confess("Need storage_group and storage_number")
        unless $st_gr_id && $st_number;

    Carp::confess("Need --input-file")
        unless $o->{'input-file'};
  
    my $in_doc_struct = tsv_read_and_validate($o->{'input-file'}, $o);

    Carp::confess("Invalid storage group id specified")
        unless defined($in_doc_struct->{'by_storage'}->{$st_gr_id});
    Carp::confess("Invalid storage number  specified")
        unless defined($in_doc_struct->{'by_storage'}->{$st_gr_id}->{$st_number});
    
    print Data::Dumper::Dumper($in_doc_struct->{'by_storage'}->{$st_gr_id}->{$st_number});

    if ($o->{'tsv-output'}) {
        tsv_output_record($in_doc_struct->{'by_storage'}->{$st_gr_id}->{$st_number}->{'tsv_struct'});
    }
} elsif ($o->{'dump-tsv-struct'}) {
    Carp::confess("Need --input-file")
        unless $o->{'input-file'};

    my $in_doc_struct = tsv_read_and_validate($o->{'input-file'}, $o);

    if ($o->{'debug'}) {
        print Data::Dumper::Dumper($in_doc_struct);
    }

    print "total input lines: " . $in_doc_struct->{'total_input_lines'} . "\n";
    print "total data lines: " . scalar(@{$in_doc_struct->{'array'}}) . "\n";
    foreach my $st_gr_id (sort keys %{$in_doc_struct->{'by_storage'}}) {
        print
            "total items in storage group [$st_gr_id] (" .
            $data_desc_struct->{'storage_groups'}->{$st_gr_id}->{'name_readable_en'} .
            "): " . scalar(keys %{$in_doc_struct->{'by_storage'}->{$st_gr_id}}) . "\n";
    }

    foreach my $fund_number (sort {$a <=> $b} keys %{$in_doc_struct->{'storage_items_by_fund_number'}}) {
        print uc($in_doc_struct->{'funds'}->{$fund_number}->{'type'}) . " " . $fund_number . ": " .
            scalar(keys %{$in_doc_struct->{'storage_items_by_fund_number'}->{$fund_number}}) . " storage items\n";
    }
} elsif ($o->{'initial-import'}) {
    Carp::confess("Need --input-file")
        unless $o->{'input-file'};

    my $target_collection_handle = $o->{'target-collection-handle'} || "123456789/2";

    my $in_doc_struct = tsv_read_and_validate($o->{'input-file'}, $o);

    my $output_labels;

    foreach my $st_gr_id (sort keys %{$in_doc_struct->{'by_storage'}}) {
        foreach my $in_id (sort {$a <=> $b} keys %{$in_doc_struct->{'by_storage'}->{$st_gr_id}}) {
            # print $st_gr_id . ":" . $in_id . "\n";
            
            next unless defined($in_doc_struct->{'by_storage'}->{$st_gr_id}->{$in_id}->{'tsv_struct'});

            my $tsv_record = $in_doc_struct->{'by_storage'}->{$st_gr_id}->{$in_id}->{'tsv_struct'};
            $tsv_record->{'collection'} = $target_collection_handle;

#            my $tsv_record = {
#                'dc.description[ru]' =>
#                    'ОФ-10141/1 "От автора". Введение к тому музейно-методических работ. Полнота: полная. Подлинность: копия. Способ воспроизведения: машинопись. Примечания: Т. I' .
#                    '||' .
#                    'НВФ-2116/460 "От автора". Введение к тому музейно-методических работ. Полнота: полная. Подлинность: оригинал. Способ воспроизведения: машинопись. Примечания: Т. I ; 1 экз.основной + 2 экз. редакции (5 лл.,6 лл.)',
#                'sdm-archive-workflow.date.cataloged' => '28.01.2012',
#                'sdm-archive-workflow.date.digitized' => '28.01.2012',
#            };
        
            if (!$output_labels) {
                tsv_output_record($tsv_record, {'mode' => 'labels'});
                $output_labels = 1;
            }
            tsv_output_record($tsv_record);
        }
    }

} elsif ($o->{'output-tsv'}) {
    my $tsv_record = {
#        'id' => "+",
        'collection' => '123456789/2',
        'dc.contributor.author[en]' => 'Kohts (Coates), Alexander Erich',
        'dc.contributor.author[ru]' => 'Котс, Александр Федорович',
        'dc.creator[en]' => 'Kohts (Coates), Alexander Erich',
        'dc.creator[ru]' => 'Котс, Александр Федорович',
        'dc.date.created' => '1948 марта 20',
        'dc.date.issued' => '',
        'dc.description[ru]' =>
            'ОФ-10141/1 "От автора". Введение к тому музейно-методических работ. Полнота: полная. Подлинность: копия. Способ воспроизведения: машинопись. Примечания: Т. I' .
            '||' .
            'НВФ-2116/460 "От автора". Введение к тому музейно-методических работ. Полнота: полная. Подлинность: оригинал. Способ воспроизведения: машинопись. Примечания: Т. I ; 1 экз.основной + 2 экз. редакции (5 лл.,6 лл.)',
        'dc.identifier.other[ru]' => 'Место хранения 403 (опись Новиковой)',
        'dc.identifier.uri' => '', # http://hdl.handle.net/123456789/4
        'dc.language.iso[en]' => 'ru',
        'dc.publisher[en]' => 'State Darwin Museum',
        'dc.publisher[ru]' => 'Государственный Дарвиновский Музей',
        'dc.subject[en]' => '',
        'dc.subject[ru]' => 'Музейное дело',
        'dc.title[ru]' => '"От автора". Введение к тому музейно-методических работ',
        'dc.type[en]' => 'Text',
        'sdm-archive-workflow.date.cataloged' => '28.01.2012',
        'sdm-archive-workflow.date.digitized' => '28.01.2012',
    };

    tsv_output_record($tsv_record, {'mode' => 'labels'});
    tsv_output_record($tsv_record, {'mode' => 'values'});
} else {
    Carp::confess("Need command line parameter, one of: " . join("\n", "", sort map {"--" . $_} @{$o_names}) . "\n");
}
